■ 세션과 프로세스 그룹

◎ 참조
  - <link contents="Session and Process Group" paht="https://mug896.github.io/bash-shell/session_and_process-group.html"/>

◎ 개요
  - 리눅스에서 실행하는 모든 프로세스는 PID와 PPID로 관리하기에 부족한 점이 있다. 이때 세션과 프로세스 그룹을 사용해 효과적으로 관리한다.
  - 실행하는 모든 프로세스는 프로세스 그룹에 속하고 프로세스 그룹은 세션에 속한다.

◎ 세션
  - 터미널을 열면 쉘이 실행되는 데, 이떄 쉘의 pid가 sid(Session ID)가 되며 session leader(PID==SID)가 된다. 이후 프롬프트로 명령을 실행해 생성한 자식 프로세스는 모드 같은 SID를 같게 된다.
  - 세션 하나에선 프로세스 그룹 하나만 포어그라운드가 될 수 있고 나머지는 백그라운드가 된다.
  - setsid command 명령으로 쉘 스크립트를 실행하면 새로운 세션에서 스크립트를 실행한다. 
    - 새로운 SID와 PGID가 할당되고 PPID도 init으로 바뀌어 실행된다.
    - SID가 바뀌므로 제어 중인 터미널에서도 떨어져나가 HUP, INT 같은 신호도 전달되지 않고, 제어 터미널에 해당하는 /dev/tty도 사용할 수 없다.
    - parent도 init이 되므로 스크립트를 데몬으로 실행하는 효과를 가진다.

◎ 프로세스 그룹
  - 프로세스 그룹은 작업 제어를 목적으로 함께 처리할 프로세스를 모은 그룹이다.
  - 쉘 스크립트를 실행하면 프로세스 그룹이 만들어지는데, 이때 스크립트 pid가 pgid(Progess Group ID)가 되어 process group leader(PID==PGID)가 된다.
    - 새로 생성하는 프로세스는 부모 프로세스의 PGID를 상속해 이후 스크립트가 실행하는 모든 프로세스는 같은 PGID를 가진다.
  - 파이프를 통해 여려 명령을 동시에 실행할 떄도 프로세스 그룹이 만들어진다. 첫번째 명령이 process group leader가 된다.
  - 프로세스 그룹은 작업 제어를할 때 기본단위(job)이 된다.
  - setsid를 사용해 SID와 PGID를 변경해 명령을 실행할 수 있지만 setpgid 같은 명령은 없다. 하지만 간접적으로 set -o monitor 옵션 설정을 통해 이후 실행하는 명령이 다른 PGID를 갖게할 수 있다.

◎ 조회하고 신호보내기
  - 현재 실행하고 있는 프로세스의 PPID, PID, PGID, SID는 ps 명령을 통해 알아볼 수 있다.
  - pgrep, pkill 명령을 사용하면 프로세스 그룹이나 세션별로 조회하거나 시그널을 보낼 수 있다.
  - 스크립트를 종료할 때는 jobspec이나 PGID를 이용해 프로세스 그룹에 신호를 보내야 한다. 그렇지 않고 스크립트 PID에만 신호를 보내면 자식 프로세스는 종료되지 않고 남아있게 된다.
    - PGID를 이용해 스크립트를 종료하는 방법은 다음과 같다.
    - kill -- -12345 # PGID 앞에 - 문자를 붙인다.
    - pkill -g 12345
