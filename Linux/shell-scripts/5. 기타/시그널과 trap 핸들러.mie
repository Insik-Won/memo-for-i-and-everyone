■ signal과 trap

◎ 참조
  - <link contents="Signals and Traps" path="https://mug896.github.io/bash-shell/signals_and_traps.html"/>

◎ 개요
  - 하드웨어가 인터럽트에 의해 운영된다면 소프트웨어는 시그널에 의해 운영된다고 할 수 있다. 시그널 기능이 없다면 오류로 무한루프를 도는 프로세스를 정지시킬 수도, 종료시킬 수도 없고, 자식 프로세스가 종료됬을 때 부모에게 알릴 수 없게 된다.
  - 시그널은 프로세스에 전달되는 소프트웨어 인터럽트라고 할 수 있다. 운영체제 내에 정의되어 있고 여러가지 시스템 이벤트가 발생했을 때 프로세스에 알리기 위해 사용된다.
    - 예: CTRL-C, 터미널 프로그램 종료, 프로세스가 다른 프로세스 종료, 두 프로세스 간 통신 등
  - 컴퓨터는 기본적으로 인터럽트로 운영되는 비동기적 머신이다. 현재 프로그램이 실행 중이라도 스크린을 터치하거나 키보드 키를 누르는 것처럼 비동기적 이벤트가 발생하면 실행을 멈추가 해당 인터럽트를 처리한다. 시그널도 이와 같은 비동기적 이벤트에 해당한다.

◎ 시그널 보내기 (signal sending)
  - 시그널은 보내는 쪽에서 임의로 아무떄나 상대 프로세스에게 보낼 수 있다. 시그널은 운영체제에 의해 보내질 수도 있고 사용자가 kill 명령으로 보낼 수도 있고, 자신에게 보낼 수 도 있다.
  - 운영체제 내에서 목적지 프로세스의 PCB(Process Control Block)의 signal table에 해당 신호값을 설정하는 것으로 이루어진다.

◎ OS 스케쥴링
  - 시그널을 받는 과정을 설명하기 전에 OS 스케쥴링에 대해 알아보자.
  - 실행하는 모든 프로세스는 cpu 입장에서 보았을 때 2가지 상태를 오가면서 실행된다. CPU 명령을 실행하는 상태(cpu burst)와 IO를 대기하는 상태(I/O burst)이다. 실행중인 프로세스 A가 I/O 대기 상태가 되면 cpu는 idle상태가 되므로 OS 스케쥴러에 의해 프로세스 B로 실행이 변경된다.
  - CPU의 실행이 프로세스 A에서 프로세스 B로 변경하는 것을 context switching이라고 한다. 프로세스 A에서 실행중인 cpu 상태(register 값들)가 백업되어 저장되고 이전에 저장했던 프로세스 B의 cpu 상태가 로드되어 실행을 계속한다.
  - 프로세스 상태를 운영체제 관점에서 5가지로 구분해볼 수 있다. 먼저 프로세스가 생성되면(new) 스케쥴러가 관리하는 ready queue에 들어가고(ready), 이후에 스케쥴러에 의해 실행된다(running). 실행 중인 프로세스는 I/O wait이 발생하거나 wait() 시스템 콜을 수행하면 waiting 상태로 변경되고 scheduled out된다. 또한 running 상태에서 프로세스에 할당한 시간이 만료되거나 스케쥴러에 의해 인터럽트되면 실행이 중단되어 ready 상태가 되고 다음 프로세스가 running하게 된다. 프로세스가 실행을 완료하거나 종료 신호를 받으면 exit(terminate)된다.
    - <img contents="프로세스 상태변화 그래프" path="./image/프로세스 상태변화.png"/>
  - 실행중인 프로세스가 context switching되는 것은 직접 스케쥴러 함수를 호출하거나(voluntary_switch), timer interrupt에 의해 스케쥴러가 실행되면서 발생할 수 있다.(involuntary_switch) /proc/$PID/sched 또는 /proc/$PID/status를 통해 값을 조회해볼 수 있다.
  - 프로세스가 종료되는 방식은 exit에 의한 정상 종료와 시그널에 의한 비정상 종료가 있다. 
    - <img contents-"정상 종료와 비정상 종료" path="./image/프로세스 종료방식.png"/>

◎ 시그널 받기 (signal receiving)
  - 시그널을 받는다는 것은 스케쥴러에 의해 프로세스가 실행을 재개하기 전 PCB의 signal table을 좋회하여 설정되있을 경우, 해당 시그널 핸들러를 실행하는 것을 의미한다.
  - 시그널을 보내고(sending) 받을(receving) 떄까지 사이, 그러니깐 신호가 전달되어 PCB 신호 항목이 설정되어 있으나 아직 시그널 핸들러가 실행되지 않는 동안을 pending이라고 한다. 이때 동안 다시 신호가 전달된다면 무시되어 하나만 남게 된다. (비트 플래그라 보면 된다.)
  - 실제 설정한 신호값을 조회하고 처리하는 시점은 프로세스가 kernel 모드에서 user 모드로 복귀할 떄이다. 인터럽트, 시스템 콜 처리를 위해서는 kernel 모드 진입과 user 모드 복귀를 수반하므로 현재 실행 중에 있는 프로세스라도 신호가 처리될 수 있다.

◎ 시그널 핸들러 (signal handler)
  - 시그널이 프로세스 전달됬을 떄 실행하는 코드를 시그널 핸들러라고 한다. 모든 시그널은 기본 시그널 핸들러를 가진다. 그래서 SIGTSTP 신호가 전달되면 프로세스가 중단되고 SIGTERM 신호를 받으면 종료한다. 쉘에서는 trap 명령을 이용해 사용자가 직접 시그널 핸들러를 등록해 사용할 수 있다.
  - 하드웨어 인터럽트와 시그널의 다른 점은 인터럽트는 커널 모드에서 OS가 처리하지만 시그널은 user 모드에서 사용자 프로그램에 의해서도 처리된다는 것이다.

◎ kill 명령
  - kill [-s sigspec | -n signum | -sigspec] pid|jobspec ...
  - kill -l [sigspec]
  - 해당 프로세스/작업에 시그널을 보낸다.
  - 시그널 목록을 보면 알겠지만 대부분의 시그널은 치명적인 오류를 나타내고 기본 동작으로 프로세스를 종료한다. 왜 명령 이름이 kill인지 알 수 있다.
  - 신호값이 없으면 기본값은 TERM 신호가 된다. 시그널명으로 풀네임을 쓸 수도 있고 앞의 SIG를 제외하거나 소문자로 쓸 수도 있다.
  - 프로세스 그룹에 시그널을 보낼려면 앞에 -를 붙여 PGID를 쓰면 된다. 이떄 옵션값과 구분하기 위해 앞에 --를 쓸 수 있다.
  - 시그널 번호로 0을 주면 실질적으로 신호를 보내진 않지만 프로세스가 아직 살아있는지, 살아있다면 신호를 보낼 권한이 되는지 테스트할 수 있다.
  - PID 번호로 0을 주면 kill 명령을 호출한 프로세스이 속한 프로세스 그룹 전체에게 신호를 전달한다. 

◎ trap 명령
  - trap [-lp] [[arg] signal_spec ...]
  - 시그널을 가로채 필요한 작업을 수행하는 시그널 핸들러를 등록할 수 있다.
  - 스크립트를 실행하면서 생성한 임시파일이나 named pipe 같은 리소스를 뒤처리하는 작업을 등록할 수가 있다.
  - 예)
    - <code name="예시" type="shell">
      # 사용자 시그널 핸들러를 등록해 실행
      myhandler() { ... ;}
      trap 'myhandler' INT
      
      # 기존에 설정한 사용자 핸들러를 기본 핸들러로 초기화
      trap INT
      trap - INT
      
      # 시그널을 무시하는 핸들러 설정
      trap '' INT

      # 아무 설정도 하지 않으면 기본 핸들러가 실행된다.
    - </code>
  - trap 명령으로 핸들러를 등록할 수 없는 시그널은 다음과 같다: SIGKILL, SIGSTOP, SIGCONT
  - bash는 사용자의 편의를 위해 가상 시그널을 제공한다.
    - EXIT: shell이 종료할 때 발생 (하위쉘도 적용 가능)
    - ERR: 명령이 0이 아닌 값을 반환할 경우 발생
    - DEBUG: 매 명령 실행 전 발생
    - RETURN: 함수/soure한 스크립트가 반환할 때

    - 가상 시그널 핸들러는 하위 쉘까지 적용할 수 있으며(functrace, errtrace 설정 시), 하위 프로세스에는 적용되지 않는다.
    - EXIT 핸들러를 다른 종료 시그널 핸들러(INT, HUP, QUIT, TERM)와 함께 등록했다면 다른 시그널 핸들러가 먼저 실행되고 EXIT 핸들러가 그 뒤에 실행된다.
    - ERR, DEBUG, RETURN 가상 시그널은 디버깅에 사용된다.
  - trap 핸들러는 현재 쉘에서 실행되므로 하위 쉘에서 발생한 시그널이라도 현재 쉘에서 실행된다.
  - sh도 EXIT 시그널을 제공하지만 bash가 제공하는 기능이 아니다. 스크립트가 정상 종료될 때, exit 명령을 이용한 종료, set -e에 의해 종료할 때만 호출된다.
  
  - CTRL-C(INT) 신호를 이용한 trap은 3가지로 활용할 수 있다.
    - 사용자가 CTRL-C로 종료하지 못하게 무시하기
    - 자식 프로세스만 종료시키기
    - 프로세스 그룹 전체를 종료시키기
  - CHLD 신호
    - 쉘에서 CHLD 신호를 trap하는 것은 별 의미가 없다. 왜냐하면 trap은 기본적으로 명령을 다루기 때문에 매 명령 실행시마다 CHLD 신호 trap이 발생하기 때문이다.

