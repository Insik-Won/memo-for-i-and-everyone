■ 특수 명령

◎ 참조
  - <link path="https://mug896.github.io/bash-shell/special_commands.html" contents="Special Commands"/>

◎ 개요
  - 쉘은 기본적으로 "command arg1 arg2 ..." 형식의 명령을 다루지만 그 외에 shell 자체에서 제공하는 명령이 있다. 이 명령을 특수 명령이라고 한다.
  - 특수 명령은 쉘이 직접 해석하고 실행하기 때문에 사용방법에 있어서 연산자를 이스케이프한다든가 변수를 따옴표로 감싸 사용해야하는 제약 없이 편리하게 사용할 수 있다.
  - (( )), let은 산술 연산에 특화된 기능을, [[ ]]는 [ 명령과 같이 테스트에 특롸된 기능을 제공한다.
  - 특수 명령은 bash 전용으로 sh에서는 사용할 수 없다.

◎ (( ))
  - (( 명령은 산술 연산을 위한 명령으로 문자열은 다루지 않고 숫자만 다룬다. 
  - 본문 안에 알파벳으로 된 단어가 오면 변수명으로 취급하며, 변수를 사용할 때 $를 붙이지 않아도 된다. 
  - 변수 대입도 가능하다. (+=, -= 등도 가능하다.)
  - 변수값이 숫자가 아니거나 존재하지 않는다면 0과 같다.
  - 매개변수 확장은 물론 $를 사용해야 하며 `를 통한 명령 치환도 사용할 수 있다.
  - 이 명령은 하위 쉘이 아닌 현재 쉘에서 실행한다. 그래서 현재 쉘의 변수값을 직접 변경할 수 있다.

  - 사용할 수 있는 연산자와 우선순위는 C언어와 같다. (거듭제곱은 *)
  - 종료 상태는 결과값이 0이면 false, 이외는 true이다.

◎ let
  - let 명령은 ((와 같이 산술 연산을 위한 명령어이다.
  - 하나의 인수에 하나의 식이 매칭된다. 그래서 식을 쓸 대 공백 없이 붙여 써야 한다. 물론 따옴표를 사용하면 공백을 써도 된다.
  - (( 명령과 같이 대입 연산을 사용할 수 있으며 변수를 사용할 때 $를 붙이지 않아도 된다.

◎ test 명령
  - test <연산자> <피연산자>
  - test <피연산자1> <연산자> <피연산자2> 
  - test 명령은 특수 명령은 아니지만 쉘에서 유용하게 쓰이는 명령이다. 주로 문자열이나 변수를 테스트해 분기하는 데 사용한다.
  - test 명령은 [ ]로도 쓸 수 있다. '['가 test 명령이며 ']'는 test의 끝을 알려주는 문자이다.
  - test 명령에서 연산자를 사용하지 않을 경우, 아무것도 주지 않거나 빈 문자열을 주면 false, 그 외는 모두 true를 반환한다.
  - true와 false 명령어는 쉘에서 0/1을 종료상태로 반환하는 명령어이다.
  - 비교할 변수는 따옴표로 감싸야 한다.
  - AND, OR 연산자는 -a, -o를 사용할 수도 있고 쉘 메타문자인 &&와 ||를 사용할 수도 있다.
  - NOT 연산자도 test 명령의 연산자 !를 사용할 수도 있고 쉘 키워드인 !를 사용할 수도 있다.

  - 파일 연산자
    - -a: 파일이 존재하면 (논리적 AND 연산자와 구분이 어려우니 사용 비권장)
    - -e: 파일이 존재하면
    - -f: 파일이 정규 파일이면
    - -d: 파일이 디렉토리이면
    - -c: 파일이 문자 특수 파일이면 (chracter special file)
    - -b: 파일이 블록 특수 파일이면 (block special file)
    - -p: 파일이 파이프 파일이면 (<(...)이어도)
    - -S: 파일이 소켓 파일이면
    - -L, -h: 파일이 심볼릭 링크이면

    - -O: 파일의 uid가 현재 프로세스의 유저와 같으면
    - -G: 파일의 gid가 현재 프로세스의 그룹과 같으면
    - -u: 파일의 suid 비트가 켜져있으면
    - -g: 파일의 sgid 비트가 켜져있으면
    - -k: 파일의 sticky 비트가 켜져있으면 

    - -r: 파일이 읽기 가능하면
    - -w: 파일이 쓰기 가능하면
      - 만약 read-only 파일시스템이라면 파일을 쓰기할 수 없지만 참으로 나올 수도 있다.
    - -x: 파일이 실행 가능하면
      - 만약 파일이 디렉토리라면 cd를 통해 현재 프로세스에서 이동가능한지
    
    - -N: 파일을 마지막으로 읽은 뒤로 변경했으면
    - -s: 파일의 크기가 0보다 크면
    - -t: 파일 지시자가 현재 터미널에 존재하면
  
    - -nt: 왼쪽이 오른쪽보다 수정시간이 이르면
    - -ot: 왼쪽이 오른쪽보다 수정시간이 늦으면
    - -ef: 왼쪽과 오른쪽이 하드링크되어 있다
  
  - 문자열 연산자
    - -z: 빈 문자열이거나 아예 안 들어왔으면
    - -n: 문자열이 비지 않으면

    - =: 두 문자열이 같다면
    - !=: 두 문자열이 다르다면
    - <: 왼쪽이 오른쪽보다 사전적으로 작다면
    - >: 왼쪽이 오른쪽보다 사전적으로 크다면
      - <와 >는 사용 시 이스케이프해야 한다.

  - 산술 연산자
    - -eq: 두 수가 같다면
    - -ne: 두 수가 다르다면
    - -le: 왼쪽이 오른쪽보다 작거나 같으면
    - -ge: 왼쪽이 오른쪽보다 크거나 같으면
    - -lt: 왼쪽이 오른쪽보다 작으면 
    - -gt: 왼쪽이 오른쪽보다 크면

  - 기타 연산자
    - -a: 두 테스트를 AND 연산할 때 (이항 연산자일 시)
    - -o: 두 테스트를 OR 연산할 때
    - !: 테스트를 NOT 연산할 때
    - (): 괄호로 우선순위 조절을 할 떄 (사용할 때 이스케이프)

    - -o: set 내장 명령으로 설정한 옵션의 값이 꺼져있으면
    - -v: 변수 이름이 존재한다면
    - -R: 변수가 간접참조 변수(named reference)이면 (bash 버전 4.3 이상)

◎ [[ ]]
  - [ 명령에 기능을 추가해 확장한 명령이다. 문자열과 패턴/정규표현식 매칭 기능을 제공한다.
  - 정규표현식 유형은 Extended Regular Expression이다. (\s,\w,\b와 같은 확장 기능은 아쉽게도 사용할 수 없다.)
  - &&와 || 연산자도 내부에서 제공한다.
  - sh에서는 expr 명령으로 정규식 매칭을 할 수 있다.
  
  - 문자열 연산자
    - =: 이제 문자열과 패턴도 매칭가능하다.
    - =~: 문자열과 정규표현식을 매칭한다.
      - 이때 패턴/정규표현식 문자는 이스케이프/따옴표를 쓰지 말아야 한다.
      - 비교하는 값이 배열(@,*)이나 매개변수(@,*) 전체일 경우 전체 원소가 하나의 값으로 사용된다.
      - 소괄호를 이용해 캡쳐한 값은 BASH_REMATCH 배열 변수로 들어간다. 원소 #0은 전체 매칭, 원소 #1,2,...는 해당 번째 매칭이 된다.
    