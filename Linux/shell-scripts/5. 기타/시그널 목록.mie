■ 시그널 목록 

◎ 참조
  - <link contents="Signals Table" path="https://mug896.github.io/bash-shell/signals_table.html"/>

◎ 개요
  - 시그널은 여러 하드웨어/소프트웨어에서 발생할 수 있는 예외/오류를 추상화한 인터페이스라고 볼 수 있다.
  - 시그널은 두 종료로 분류할 수 있다: synchronous(exception)와 asynchronous(interrupt).
    - synchronous 시그널은 프로세스 속 스레드가 실행 중에 자신으로부터 발생하는 오류이다. (SIGFPE, SIGILL, SIGSEGV, SIGBUS, ...)
    - asynchronous 시그널은 프로세스 외부에서 비동기적으로 발생하는 인터럽트이다. 
    - 프로세스 하나에서 스레드 여러개가 실행 중일 수도 있는데, 이 synchronous 시그널은 스레드단에서 처리된다.
      - 기본적으로 프로세스 내 모든 스레드는 시그널 핸들러를 공유하고, 각 스레드별로 signal mask를 설정할 수 있다. 따라서 특정 스레드에서 시그널 처리를 전담하게 하려면 해당 스레드에서만 시그널을 unmask시키고 나머지 스레드에서 모두 mask시키면 된다. (signal mask는 부모 스레드로부터 상속된다.)
  - 시그널은 이름과 번호를 가지고 있는데 번호는 POSIX 표준으로 정해진 것이 몇 안되고 운영체제별로 그 번호가 다르다.
  - 시그널은 기본 행동을 가지며 동작은 다음과 같다.
    - 종료: 프로세스를 종료한다.
    - 종료(코어 덤프): 프로세스를 종료하고 추가적으로 core 파일을 생성한다.
    - 무시: 신호를 무시한다.
    - 중지: 프로세스를 중지한다. (종료x)
    - 계속: 프로세스가 중지 상태일 경우 실행을 재개한다. (실행 상태에는 무시된다.)

◎ 프로그램 오류 시그널
  - 프로그램 오류 시그널은 모두 기본행동이 종료(코어 덤프)이다.

  - SIGFPE: 산술연산 오류를 나타낸다. 이름은 floating-point exception에서 따왔지만 실질적으로 모든 산술연산 오류를 포함한다.
  - SIGILL: 프로세스가 illegal,malformed,unknown,previleged instruction을 실행하려 하면 전달된다.
  - SIGSEGV: 프로세스에 할당한 메모리 주소 범위를 벗어나 참조하면 segmentation violation이 발생하고 신호가 프로세스에 전달된다. (혹은 read-only memory에 쓸 경우)
  - SIGBUS: 정렬되지 않은 메모리 주소를 사용하거나 존재하지 않는 물리적 주소를 사용하면 프로세스에 전달된다.
  - SIGABRT(6): 프로그램 코드에서 비정상 종료를 할 경우 나타내며 abort 함수를 이용해 종료할 때 발생한다.
  - SIGTRAP: 디버깅에서 사용하는 신호로 특정 함수 실행,변수값 변경 같은 상황이 발생하면 전달된다.
  - SIGEMT: 소프트웨어로 예뮬레이션되지 않은 instruction을 실행하거나 운영체제에서 emulation 실패가 발생하면 프로세스에 전달된다.
  - SIGSYS: 시스템 콜을 할 때 인수 전달에 오류가 있으면 발생한다. 시스템 콜을 하기 위해 주로 libc를 이용하므로 실질적으로 거의 발생하지 않는다.

◎ 종료 시그널
  - 종료 시그널의 기본 행동은 종료이다. (SIGQUIT만 종료(코어덤프)이다.)

  - SIGTERM(15): 프로세스 종료를 요청할 떄 사용한다. SIGKILL과 달리 trap하거나 ignore할 수 있다. 시그널 핸들러를 이용해 종료하기 전 필요한 뒤처리 작업을 할 수 있다.
  - SIGINT(2): 실행 중인 프로세스를 interrupt할 때 사용하는 신호이다. 터미널에서 CTRL-C를 입력하면 프로세스에 전달되고 실행 중인 프로세스는 전달된다.
  - SIGQUIT(3): 터미널에서 CTRL-\를 입력하면 발생하며, 프로세스가 종료할 떄 추가로 core dump한다. 사용자에 의한 에러 발견으로 볼 수 있다.
  - SIGKILL(9): 이 신호를 받은 프로세스는 즉시 종료한다. SIGTERM, SIGINT와 달리 trap/ignore할 수 없으며 필요한 뒤처리 작업을 할 수 없다.
  - SIGHUP(1): 터미널/모뎀/네트워크와 연결이 끊기거나 터미널 프로그램이 종료될 경우 모든 자손 프로세스들에게 전달된다. 또 용도가 하나 더 있는데 대몬 프로세스에서 사용하는 설정파일을 수정할 경우 restart할 필요 없이 이 신호를 보내면 설정파일을 reload한다.

◎ 알람 시그널
  - 알람 시그널의 기본 행동은 종료이다.

  - SIGALRM(14): alarm/setitimer 함수에서 설정한 값이 초과하면 발생한다. 측정에는 real 또는 clock 시간이 사용된다.
  - SIGVTALRM: 현재 프로세스에서 CPU 시간이 alram/setitimer 함수에서 설정한 값을 초과했을 경우 발생한다. (Virtual Time ALRAM)
  - SIGPROF: 프로세스에서 사용한 cpu 시간 + 프로세스를 대신해 시스템 콜을 하는데 소비한 cpu 시간이 alaram/setitimer 함수에서 설정한 값을 초과했을 경우 발생한다. code profiling하는 프로그램에서 사용한다. 

◎ 비동기 시그널
  - 비동기 시그널의 기본 행동은 무시이며 번호는 정해져 있지 않다.

  - SIGIO: 소켓이나 터미널 같은 파일 지시자에서 입출력 준비가 되면 발생한다. 커널이 호출자를 대신해서 파일 지시자를 조사해 신호를 전달하므로 비동기 I/O 요청을 만들 때 사용할 수 있다.
  - SIGURG: 소켓에서 urgent 혹은 out-of-band 데이터가 도착하면 전달된다.
  - SIGPOLL: System V 신호 이름으로 SIGIO와 같다. 호환성 유지를 위해 정의되어 있다.

◎ 작업 관리 시그널
  - 작업 관리 시그널의 기본 행동은 중지이다. (SIGCHLD는 무시, SIGCONT는 계속이다.)
  - SIGCHLD: 자식 프로세스가 terminate/stop/continue 상태변경이 되면 부모 프로세스에게 전달한다.
  - SIGCONT: SIGSTOP/SIGTSTP 신호로 중단된 프로세스를 다시 시작한다. (실행 중인 프로세스에서는 무시된다.)
  - SIGSTOP: 비터미널 종료 시그널. 이 신호를 받으면 프로세스는 즉시 정지한다. trap/ignore할 수 없다.
  - SIGTSTP: 터미널 종료 시그널. 터미널에서 CTRL-Z 키를 입력할 때 발생하며 SIGSTOP과 달리 trap/ignor할 수 있다.
  - SIGTTIM: 백그라운드 프로세스가 터미널로부터 읽기를 시도하면 전달된다.
  - SIGTTOU: 백그라운드 프로세스가 터미널로부터 쓰기를 시도하면 전달된다. 터미널 옵션 tostop이 활성화되어 있어야 한다. (stty)

◎ 운영체제 오류 시그널
  - 운영체제 오류 시그널의 기본 행동은 종료이다.
  - SIGPIPE: broken pipe를 나타낸다. writer가 파이프로 데이터를 쓰고 있는 중에 reader가 종료하거나, connect되지 않은 소켓에 데이터를 전송하면 발생한다.
  - SIGLOST: Resource lost를 의미한다. 가령 NFS에서 파일에 lock을 하고 있는데 NFS 서버가 리부팅되어 lock을 읽어버리게 되면 신호가 프로세스에 전달된다.
  - SIGXCPU: 사용가능한 CPU 시간(soft limit)을 초과할 경우 전달되며 신호를 받은 프로세스는 필요한 뒤처리 작업을 할 수 있고, 이후 운영체제의 SIGKILL 신호에 의해 종료된다.
  - SIGXFSZ: 시스템에서 사용가능한 파일 크기(soft limit)을 초과하려할 때 발생한다.

◎ 기타 시그널
  - SIGUSR1,SIGUSR2는 기본 행동이 종료, SIGWINCH,SIGINFO는 기본 행동이 무시이다.
  - SIGUSR1, SIGRUSR2: 사용자가 정의하여 사용할 수 있는 신호이다.
  - SIGWINCH: 터미널 윈도우 크기가 변경되었을 때 프로세스에 전달한다.
  - SIGINFO 터미널의 포어그라운드 프로세스 그룹에 모두 전달되며, process group leader는 시스템 상태 정보와 프로세스가 실행 중인 작업에 대한 정보를 표시한다.

◎ real time 시그널 (RTS)
  - SIGRTMIN ~ SIGRTMAX는 real time 시그널이다. (kill -l에서 확인 가능) Unix 표준 시스널에서는 시그널이 블록될 경우, 하나의 시그널만 유지하고 나머지는 모두 읽어버리지만 RTS는 블록되더라도 시그널의 queue를 유지한다. 또한 순서 정렬도 보장하는데 블록된 상태에서 각기 다른 번호의 신호가 도착할 경우, 작은 번호의 신호가 먼저 전달된다. 
  - RTS는 커널에 의해 사용되지 않으며 비동기 이벤트를 전달하기 위한 목적으로 만들어졌다. 주로 네트워크 어플리케이션 작성 시 소켓 이벤트를 통보하기 위해 사용한다. RTS는 네트워크 입출력에 있어서 polling에 비해 월등한 성능 향상을 보장한다. 시그널의 장점인 실시간성을 유지하면서 단점인 queue 부재의 문제를 해결한 향상된 시그널 도구라고 할 수 있다.
  - 유닉스 표준 시그널과 real time 시그널이 동시에 블록상태가 되면, 리눅스의 경우 표준 시그널이 우선순위를 갖는다.

  - 유닉스 표준 시그널
    - 1. 시그널이 블록된 상태에서 동일한 시그널이 여러개 전달되면 하나만 유지된다. (앞선 시그널이 overwrite되지 않는다.)
    - 2. 블록된 상태에서 다른 종류의 시그널이 여러개 전달될 경우 실행 순서는 undefined이다.
  - real time 시그널
    - 1. 시그널이 블록된 상태에서 동일한 시그널이 여러개 전달되어도 큐가 유지된다.
    - 2. 같은 종류일 시그널일 경우 전달된 순서대로 실행되고 다른 종류의 시그널일 경우 작은 번호의 시그널이 먼저 실행된다.
