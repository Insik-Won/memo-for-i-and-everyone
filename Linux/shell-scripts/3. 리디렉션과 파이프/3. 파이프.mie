■ 파이프

◎ 참조
  - <link contents="pipe" path="https://mug896.github.io/bash-shell/pipe.html"/>

◎ 개요
  - ls | head -n 5 | sort
  - 파이프(|)는 명령어들의 출력과 입력을 이어서 하나의 명령어처럼 수행하게 하는 기능을 말한다.
  - 필요한 명령을 고르고, 적절한 옵션을 준 후, 파이프로 연결을 해 모듈 프로그래밍을 하듯이 명령어를 조합할 수가 있다.
  - Unix의 기본 철학을 보통 모듈화라고 한다. 다시 말해 각기 독립적인 역할을 하는 프로그램을 만들어 필요에 따라 서로 조합하여 전체를 완성한다는 것이다.

◎ 설명
  - 파이프의 표준 스트림 구조는 앞 명령의 stdout이 뒤 명령의 stdin으로 연결되어 있는 방식이다. 따라서 stderr은 바로 터미널로 표시된다.
  - 파이프로 연결된 명령은 하위 쉘에서 실행된다. 여기서 하위 쉘에서 실행할 명령이 하나만 있을 경우, 하위 쉘의 프로세스가 명령로 실행할 프로세스로 대체된다.
  - 파이프로 연결된 명령은 동시에 실행된다. 
    - cmd1 | cmd2와 같이 명령이 실행될 경우
    - 1. cmd1과 cmd2는 동시에 병렬로 실행한다.
    - 2. cmd1이 cmd2보다 빠르면 파이프의 write는 블록되고 더이상 진행되지 않는다.
    - 3. cmd2가 cmd1보다 빠르면 파이프의 read는 블록된다.
    - 4. cmd1이 먼저 종료하면 파이프는 close되고 cmd2는 EOF를 인식해 종료한다.
    - 5. cmd2가 먼저 종료하면 파이프는 close되고 cmd1는 다음번 write에 SIGPIPE 신호를 받고 종료한다.
  - 파이프로 연결한 명령의 종료 상태는 마지막 명령의 종료 상태를 따른다.
    - 만약에 shopt -s pipefail 옵션을 설정하면 중간에 false로 종료한 명령이 있을 경우, 파이프 종료 상태값은 false가 된다.
    - $PIPESTATUS라는 배열 변수에 파이프로 연결된 모든 명령의 종료 상태값이 들어간다.
  - 파이프로 연결한 명령은 서브쉘에서 실행되지만 shopt -s lastpipe 옵션을 설정하면 파이프의 마지막 명령이 현재 쉘에서 실행되게 할 수 있다.
  - 파이프로 연결한 명령은 프로세스 그룹을 형성한다. 이때 파이프로 연결된 명령들 중 첫번째 명령의 PID가 프로세스 그룹의 PGID가 된다.
  - 파이프로 연결한 명령은 명령 그룹이거나 백그라운드 명령이어도 된다.

◎ 이름있는 파이프
  - mkfifo pipe_path
  - '|' 파이프는 사용된 후에 사라진다. 이때 생성하는 파이프를 이름이 없다고 해서 unnamed pipe, anonymous pipe라고 한다
  - 직접 파이프를 만들어 사용할 수도 있다. 이를 named pipe라고 하며 mkfifo 명령어를 통해 파일로 만들 수 있다.
  - named pipe의 특징은 다음과 같다.
    - named pipe는 일반 파일과 달리 데이터를 디스크에 저장하지 않는다.
    - named pipe는 데이터를 저장하지 않기 때문에 파이프의 내용을 랜덤 접근할 수 없다.
    - named pipe는 FIFO 형식으로 데이터를 전달한다.
    - named pipe는 블록된다. pipe로 데이터를 쓸 때 데이터를 읽는 상대편이 없으면 블록된다. 반대로 데이터를 읽을 때도 데이터를 쓰는 상대편이 없으면 블록된다.
    - named pipe로 reader와 writer가 연결된 상태에서 writer가 먼저 종료하는 것은 오류가 되지 않지만 writer가 지속적으로 pipe를 쓰는 상태에서 reader가 먼저 종료하면 writer는 broken pipe 오류로 종료하게 된다.
      - 이 문제를 해결하기 위해 임의의 파일 지시자에 파이프를 연결하면 broken pipe 문제가 일어나지 않게 해결할 수 있다.
  - 활용 예
    - <code>
      $ mkfifo mypipe
      $ nc -l localhost 8080 < mypipe | nc korea.gnu.org 80 > mypipe
    - </code>
    - named pipe를 통해 파이프의 명령 간 양방향 연결이 가능하다.
  - 파이프는 단방향이기에 두 프로세스가 서로 대화를 나누기 위해서는 두개의 파이프가 필요하다. 이를 이용하기 위해 사용하는 명령이 바로 coproc이다. coproc 명령은 입력/출력용으로 두개의 파이프를 만들어 입력 파이프를 통해 외부 프로세스로부터 입력을 받고 연산 결과를 파이프를 통해 전달한다.

◎ 소켓
  - named pipe의 경우 프로세스 A가 파이프로 값을 쓰면 프로세스 B가 읽을 수 있다. 그 역도 가능하지만 프로세스 A가 자신이 쓰고 자신이 바로 읽으면 프로세스 B는 값을 읽을 수 없게 된다.
  - Unix의 소켓은 named pipe처럼 디렉토리에 소켓 파일을 만들어 시스템 내의 프로세스와 통신할 수 있다. 이때 데이터의 교통정리를 커널이 해주어서 named pipe에서 생길 수 있는 문제를 해결할 수 있다.
  - 터미널에서 nc 명령을 이용해 socket을 만들고 직접 통신할 수도 있다.
    - 터미널1에서 nc -lU mysocket 명령을 실행하면 mysocket 파일이 생성되고 접속대기 상태가 된다.
    - 터미널2에서 이어서 nc -U mysocket 명령을 실행하면 드 프로세스가 연결되고 서로 메세지를 주고 받을 수 있다.
  - bash에서는 스크립트에서 직접 socket에 연결할 수 있는 기능을 다음과 같은 형식을 통해 제공한다. protocol은 tcp 또는 udp를 사용할 수 있다.
    - exec {file-descriptor}<> /dev/{protocol}/{host}/{port}
    - command > /dev/{protocol}/{host}/{port}
